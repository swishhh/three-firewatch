<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Three js fire-watch</title>
    <style>
        body { margin: 0; }
    </style>
</head>
<body>
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.146.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.146.0/examples/jsm/"
    }
  }
</script>
<div id="container"></div>
<script type="module">
    import * as THREE from 'three';
    import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
    const renderer = new THREE.WebGLRenderer({
        clearAlpha: 1,
        clearColor: 0xdddddd,
        antialias: true
    });
    renderer.setClearColor('#1b1c25');

    const textureLoader = new THREE.TextureLoader();

    const container = document.getElementById('container')
    container.appendChild(renderer.domElement);


    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );

    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    camera.position.z = 0;
    camera.position.y = 20;
    camera.lookAt(scene);

    const loader = new OBJLoader();

    let updateCallbacks = [];

    const treeManager = {
        object: null,
        load: function (x = 0, y = 0, z = 0, scale = 1) {
            loader.load('obj/lowpolytree.obj', (model) => {
                this.object = model.children[0];
                this.object.material.some((material) => {
                    let color = material.name === 'Leaves' ? '#164200' : '#472706'
                    material.color = new THREE.Color(color);
                })

                this.draw(x, y, z, scale)
            });
        },
        getNewInstance: function () {
            return new THREE.Mesh(this.object.geometry, this.object.material);
        },
        draw: function (x, y, z, scale = 1) {
            if (this.object === null) {
                this.load(x,y,z, scale);
            } else {
                let tree = this.getNewInstance();
                tree.position.x = x;
                tree.position.y = y + (1.9 * scale);
                tree.position.z = z;
                tree.scale.x = scale;
                tree.scale.y = scale;
                tree.scale.z = scale;
                tree.castShadow = true;
                tree.receiveShadow = true;
                scene.add(tree);
                window.tree = tree;
            }
        }
    }

    const addSpotLight = (color, x, y, z, intensity = 1) => {
        let light = new THREE.SpotLight(color, intensity);
        light.castShadow = true;
        light.position.x = x;
        light.position.y = y;
        light.position.z = z;

        light.shadow.mapSize.width = 252;
        light.shadow.mapSize.height = 252;
        light.shadow.camera.near = 0.5;
        light.shadow.camera.far = 1500;
        light.shadow.focus = 10;

        scene.add(light);
    }

    const addAmbientLight = (color, intensity) => {
        let light = new THREE.AmbientLight(color, intensity);
        scene.add( light );
    }

    const addFireCampLight = (color, x, y, z, intensity, distance, blinking = false) => {
        let light = new THREE.PointLight(color, intensity, distance);
        light.castShadow = true;
        light.position.set(x, y, z);
        light.shadow.mapSize.width = 2048;
        light.shadow.mapSize.height = 2048;
        light.shadow.radius = 20;
        scene.add(light);
        blinking && setInterval(() => {
            let newIntensity = intensity - (Math.random() / 1.5);
            if (newIntensity <= 1.5) {
                newIntensity+= 0.4;
            }
            light.intensity = newIntensity;
            light.position.y = y + ((intensity - newIntensity) / 5);
        }, 100);
    }

    const generateTerrain = () => {
        const segmentsX = 100;
        const segmentsZ = 100;
        const sizeX = 1.1 * segmentsX;
        const sizeZ = 1.1 * segmentsZ;

        let geometry = new THREE.PlaneBufferGeometry(
            sizeX,
            sizeZ,
            segmentsX,
            segmentsZ
        );
        geometry.rotateX(Math.PI * -0.5);
        let material = new THREE.MeshStandardMaterial( { color: 0x888888 } )
        const terrain = new THREE.Mesh(geometry, material);

        terrain.receiveShadow = true;
        scene.add(terrain)
        terrain.scale.set(0.3, 0.3, 0.3)

        const totalSegmentsX = segmentsX + 1;
        const totalSegmentsZ = segmentsZ + 1;

        for(let z = 0; z < totalSegmentsZ; z++) {
            for(let x = 0; x < totalSegmentsX; x++) {
                const index = 3 * (z * totalSegmentsX + x);
                let r = 20;
                let center = segmentsX / 2;

                geometry.attributes.position.array[index + 1] = (z - center) * (z - center) + (x - center) * (x - center) <= r * r
                    ? (Math.random() / 1.5) * .3
                    : Math.random() * 2;
            }
        }
    }

    const addFireCamp = (x, y, z) => {
        loader.load('obj/firecamp.obj', (model) => {
            scene.add(model);
            model.position.set(x, y, z)
            model.scale.set(.3, .3, .3);
            model.rotateY(45)
            model.traverse((child) => {
                if (child.isMesh) {
                    if (child.name.indexOf('tree') !== -1) {
                        child.material.color = new THREE.Color('#bd8446');
                    } else if (child.name.indexOf('rock') !== -1) {
                        child.material.color = new THREE.Color('#2f2f2d');
                    } else if (child.name.indexOf('cauldron') !== -1) {
                        child.material.color = new THREE.Color('#131313');
                    } else if (child.name.indexOf('fire') !== -1) {
                        child.material.color = new THREE.Color('#d21201');
                    }
                }
            })
        });
    }

    const addRocks = (positions, rotateYDeg) => {
        loader.load('obj/rocks.obj', (model) => {
            window.rocks = model;
            scene.add(model);
            model.rotateY(rotateYDeg)
            model.position.set(...positions)
            model.traverse((child) => {
                if (child.isMesh) {
                    if (child.name.indexOf('Icosphere') !== -1) {
                        child.material.color = new THREE.Color('#656563');
                    }
                    child.receiveShadow = true;
                    child.castShadow = true;
                }
            })
        });
    }

    const addTent = () => {
        loader.load('obj/tent.obj', (model) => {
            window.tent = model;
            scene.add(model);
            model.position.set(2, 0, 6)
            model.rotateY(29)
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material.some((material) => {
                        if (material.name.indexOf('brown') !== -1) {
                            material.color = new THREE.Color('#381801');
                        }
                        if (material.name.indexOf('green') !== -1) {
                            material.color = new THREE.Color('#d2d1d1');
                        }
                    })
                    child.receiveShadow = true;
                    child.castShadow = true;
                }
            })
        });
    }

    const addFog = (color, near, far) => {
        scene.fog = new THREE.Fog(color, near, far);
    }

    const addFallingSnow = (snowVelocity = 50) => {
        let geometry = new THREE.BufferGeometry();

        let numOfFlakes = 2500;
        let positions = []; let velocities = [];
        let minRange = 15; let maxRange = 22;
        let minHeight = 0;

        const addSnowFlakes = () => {
            for (let i = 0; i < numOfFlakes; i++) {
                positions.push(
                    Math.floor(Math.random() * maxRange - minRange),
                    Math.floor(Math.random() * minRange + minHeight),
                    Math.floor(Math.random() * maxRange - minRange)
                );
                velocities.push(
                    Math.floor(Math.random() * 6 - 3) * (snowVelocity / 10000),
                    Math.floor(Math.random() * 5 + .12) * (snowVelocity / 10000),
                    Math.floor(Math.random() * 6 - 3) * (snowVelocity / 10000),
                )
            }
        }

        addSnowFlakes();

        let flakeMaterial = new THREE.PointsMaterial({
            size: .05,
            map: textureLoader.load('textures/sprites/snowflake.png'),
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: false,
            opacity: 0.7
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));

        let particles = new THREE.Points(geometry, flakeMaterial);
        window.particles = particles;
        particles.position.set(0, 0, -1)
        scene.add(particles);

        let updateSnow = () => {
            for (let i = 0; i < numOfFlakes * 3; i += 3) {
                particles.geometry.attributes.position.array[i] -= particles.geometry.attributes.velocity.array[i];
                particles.geometry.attributes.position.array[i + 1] -= particles.geometry.attributes.velocity.array[i + 1];
                particles.geometry.attributes.position.array[i + 2] -= particles.geometry.attributes.velocity.array[i + 2];

                if (particles.geometry.attributes.position.array[i+1] < 0) {
                    particles.geometry.attributes.position.array[i] = Math.floor(Math.random() * maxRange - minRange);
                    particles.geometry.attributes.position.array[i + 1] = Math.floor(Math.random() * minRange + minHeight) / 2;
                    particles.geometry.attributes.position.array[i + 2] = Math.floor(Math.random() * maxRange - minRange) / 2;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
        }

        updateCallbacks.push(updateSnow);
    }

    const addOrbitControls = () => {
        let controls = new OrbitControls(camera, renderer.domElement);
        updateCallbacks.push(controls.update);
    }

    const makeCloudMovable = (
        cloud,
        moveByAxis,
        maxAxisValue,
        minAxisValue,
        step,
        opacityThreshold
    ) => {
        cloud.material.transparent = true;
        step = step / cloud.scale.z;
        let callback = () => {
            let vector = new THREE.Vector3(
                cloud.position.x,
                cloud.position.y,
                cloud.position.z
            );
            vector[moveByAxis] += step;
            if (vector[moveByAxis] > maxAxisValue) {
                vector[moveByAxis] = minAxisValue
            }
            cloud.position.lerp(vector, 1);
            let pos = vector[moveByAxis];
            pos = (Math.abs(pos > opacityThreshold ? maxAxisValue : minAxisValue) - Math.abs(pos))
            cloud.material.opacity = (pos / step) * (1 / (opacityThreshold / step));
        }
        updateCallbacks.push(
            callback.bind(cloud, moveByAxis, step, maxAxisValue, minAxisValue, opacityThreshold)
        );
    }

    const addCloud = () => {
        loader.load('obj/cloud.obj', (model) => {
            let object = model.children.pop();
            let map = [
                [
                    [-1, 12, 1], [.7, .7, .7]
                ],
                [
                    [-10, 9, -3], [.6, .5, .6]
                ],
                [
                    [5, 10, 4], [.4, .4, .4]
                ],
                [
                    [9, 11, -4], [.8, .8, .8]
                ],
                [
                    [-2, 8.5, -10], [.3, .3, .3]
                ],
                [
                    [-5, 10, 8], [.9, .9, .9]
                ],
                [
                    [8, 9, 10], [.25, .25, .25]
                ],
            ];

            for (let i = 0; i < map.length; i++) {
                let cloud = new THREE.Mesh(object.geometry.clone(), object.material.clone());
                cloud.position.set(...map[i][0])
                cloud.scale.set(...map[i][1])
                cloud.receiveShadow = true;
                cloud.castShadow = true;
                scene.add(cloud);
                makeCloudMovable(
                    cloud,
                    'z',
                    18,
                    -18,
                    0.007,
                    3
                )
            }
        });
    }

    const addPointLight = (color, x, y, z, intensity, distance, blinking = false, castShadow = true) => {
        let light = new THREE.PointLight(color, blinking ? 0 : intensity, distance);
        light.position.set(x, y, z);
        scene.add(light);
        light.castShadow = castShadow;
        blinking && setInterval(() => {
            light.intensity = intensity;
            setTimeout(() => {
                light.intensity = 0;
            }, 500);
        }, 2000);
    }

    const addFireWatch = (position, scale, rotateY) => {
        loader.load('obj/firewatch.obj', (model) => {
            scene.add(model);
            model.position.set(...position);
            model.scale.set(...scale);
            model.rotateY(rotateY)

            let glassMaterial = new THREE.MeshPhysicalMaterial({
                reflectivity: 1.0,
                transmission: 1.0,
                roughness: 0,
                metalness: 0,
                color: new THREE.Color('#9f9fbd'),
                ior: 5,
                thickness: .5
            });
            model.traverse((child) => {
                if (child.isMesh) {
                    let materialName = child.material.name;
                    let material = child.material;
                    if (materialName.indexOf('roof') !== -1) {
                        material.color = new THREE.Color('#850707');
                    } else if (materialName.indexOf('wood') !== -1) {
                        material.color = new THREE.Color('#251106');
                    } else if (materialName.indexOf('Door') !== -1) {
                        material.color = new THREE.Color('#251106');
                    } else if (materialName.indexOf('glass') !== -1) {
                        child.material = glassMaterial;
                        window.glass = child.material;
                    } else if (materialName.indexOf('rock') !== -1) {
                        material.color = new THREE.Color('#7c7c7c');
                    } else if (materialName.indexOf('iron') !== -1) {
                        material.color = new THREE.Color('#0c0c0c');
                    } else if (materialName.indexOf('stairs') !== -1) {
                        material.color = new THREE.Color('#0c0c0c');
                    } else if (materialName.indexOf('foundation') !== -1) {
                        material.color = new THREE.Color('#0c0c0c');
                    } else if (materialName.indexOf('whiteMetal') !== -1) {
                        material.color = new THREE.Color('#282828');
                    } else if (materialName.indexOf('wall') !== -1) {
                        material.color = new THREE.Color('#572c16');
                    } else if (materialName.indexOf('anten') !== -1) {
                        let position = child.getWorldPosition(new THREE.Vector3())
                        addPointLight('#ff0000', position.x, 7.7, position.z, 4, .65, true)
                        material.color = new THREE.Color('#ff0000');
                    } else if (materialName.indexOf('Door') !== -1) {
                        material.color = new THREE.Color('#251106');
                    }

                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        });
    }

    const addLampPost = () => {
        loader.load('obj/lamp-post.obj', (model) => {
            window.lamp = model;
            scene.add(model);
            model.position.set(-3, 0, -5);
            model.scale.set(.3, .3, .3);
            model.rotateY(Math.PI * -1.9)
            // model.rotateY(rotateY)
            model.traverse((child) => {
                if (child.isMesh) {
                    let materialName = child.material.name;
                    let material = child.material;
                    if (materialName.indexOf('rock') !== -1) {
                        material.color = new THREE.Color('#505050');
                    } else if (materialName.indexOf('wood') !== -1) {
                        material.color = new THREE.Color('#251106');
                    } else if (materialName.indexOf('grass') !== -1) {
                        material.color = new THREE.Color('#06250a');
                    } else if (materialName.indexOf('iron') !== -1) {
                        material.color = new THREE.Color('#0c0c0c');
                    } else if (materialName.indexOf('glass') !== -1) {
                        material.color = new THREE.Color('#ffffff');
                        material.emissive.r = 255;
                        let position = child.getWorldPosition(new THREE.Vector3())
                        addPointLight('#ff4d00', position.x - 1, 1.75, position.z + .5, 2, 10)
                    }

                    child.castShadow = true;
                    child.receiveShadow = true;
                }
            });
        });
    }

    let treesButch = [
        [0,0, -1.5],
        [1.6, 0, -0.7, 0.6],
        [-1.9, 0, -0.9, 0.7],
        [-1.8, 0, -4, 0.9],
        [-1.8, 0, -2.5, 0.5],
        [-.1, 0, -3.5, 0.65],
        [1, 0, -4.5, 0.9],
        [3, 0, -5.5, 0.81],
        [0, 0, -6.5, 1.2],
        [-2.5, 0, -6.6, 0.9]
    ];

    for (let i = 0; i < treesButch.length; i++) {
        treeManager.draw(...treesButch[i]);
    }

    treeManager.draw(4.5, 0, 4.8, 0.65);
    treeManager.draw(9.2, 0, -2.2, 1.2);
    treeManager.draw(7.8, 0, -3.2, 1);

    addSpotLight('#ffffff', -50, 25, 50, 0.25);
    addAmbientLight('#32385d', .5);
    addFireCampLight('#ff4d00', 0, 1, 2, 3, 10, true);
    addFireCamp(.3, 0, 1.9);
    generateTerrain();
    addFog('#32385d', 1, 500);
    addRocks([5.8, -.6, 1.3], 90);
    //addFallingSnow();
    addTent();
    addOrbitControls();
    addCloud();
    addFireWatch([-7, 0 , -7], [.040, .050, .040], Math.PI * -1.7);
    addLampPost();

    treeManager.draw(-6, 0, -3.2, 1);
    treeManager.draw(-5.8, 0, -1.2, .8);
    treeManager.draw(-5.8, .3, -7.9, .4);
    treeManager.draw(-6.9, 0, -6.4, .2);
    treeManager.draw(-6.9, 0, -6.4, .2);
    treeManager.draw(-7.3, 0, -7.1, .4);
    treeManager.draw(-6.5, 0, -8.9, .7);
    treeManager.draw(-4.5, 0, -7.4, .74);
    treeManager.draw(-4.5, 0, -9, .9);
    treeManager.draw(-2.5, 0, -9.3, 1.1);
    treeManager.draw(0, 0, -9, 1.3);
    treeManager.draw(2.4, 0, -7.4, .9);
    treeManager.draw(4.6, 0, -7.3, .85);
    treeManager.draw(6.1, 0, -5.4, 1.2);
    treeManager.draw(-8.3, 0, -3.8, 1);
    treeManager.draw(-9, 0, -5.4, .5);
    treeManager.draw(-8.8, 0, -9.2, .9);
    treeManager.draw(-10.5, 0, -7.6, 1.3);
    treeManager.draw(-10.6, 0, -4.8, 1.1);
    treeManager.draw(-10.1, 0, -2.2, .9);
    treeManager.draw(-8.1, 0, -1.6, 1);
    treeManager.draw(-6.5, 0, .7, 1);
    treeManager.draw(-6.7, 0, 3, .86);
    treeManager.draw(-6, 0, 4.8, .86);
    treeManager.draw(-4.2, 0, 6.4, .77);
    treeManager.draw(-6.2, 0, 6.9, 1.1);
    treeManager.draw(-2.2, 0, 7.1, 1.3);
    treeManager.draw(.3, 0, 7.5, .6);
    treeManager.draw(-.5, 0, 9.1, .9);

    window.addEventListener( 'resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight)
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    }, false);

    function animate() {
        requestAnimationFrame(animate);
        for (let i = 0; i < updateCallbacks.length; i++) {
            updateCallbacks[i]();
        }
        renderer.render( scene, camera );
    }

    animate();
</script>
</body>
</html>